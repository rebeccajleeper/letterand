<!DOCTYPE html>
<html lang="en">
<head>
  <style>
/* ── LetterAND — Combine Letter Shapes ────────────────── */

@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');

:root {
  --bg-deep: #0a0a1a;
  --bg-card: #12122a;
  --bg-input: #181838;
  --bg-hover: #1e1e42;
  --border: #252550;
  --border-glow: #3a3a70;
  --text: #eeeef5;
  --text-muted: #9999bb;
  --text-dim: #5e5e80;
  --accent-red: #ff4d6a;
  --accent-blue: #7c7cff;
  --accent-green: #3ddba0;
  --accent-cyan: #44e0f0;
  --accent-gold: #fbbf24;
  --radius: 14px;
  --radius-sm: 8px;
  --shadow-card: 0 2px 20px rgba(0, 0, 0, 0.3);
  --shadow-glow: 0 0 30px rgba(99, 102, 241, 0.08);
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: 'Inter', system-ui, -apple-system, sans-serif;
  background: var(--bg-deep);
  background-image:
    radial-gradient(ellipse 80% 60% at 50% -10%, rgba(99, 102, 241, 0.08), transparent),
    radial-gradient(ellipse 60% 40% at 80% 100%, rgba(255, 77, 106, 0.05), transparent);
  color: var(--text);
  line-height: 1.6;
  min-height: 100vh;
}

/* ── App container ─────────────────────────────────── */

.app {
  max-width: 760px;
  margin: 0 auto;
  padding: 48px 24px 100px;
}

/* ── Header ────────────────────────────────────────── */

.app-header {
  text-align: center;
  margin-bottom: 40px;
}

.app-header h1 {
  font-size: clamp(2rem, 6vw, 2.8rem);
  font-weight: 800;
  letter-spacing: -1px;
  background: linear-gradient(135deg, var(--accent-red) 0%, var(--accent-blue) 50%, var(--accent-cyan) 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 8px;
}

.subtitle {
  font-size: 1.05rem;
  color: var(--text-muted);
  font-weight: 400;
}

/* ── Explainer ─────────────────────────────────────── */

.explainer {
  background: linear-gradient(135deg, var(--bg-card), rgba(30, 30, 66, 0.6));
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 24px 28px;
  margin-bottom: 36px;
  box-shadow: var(--shadow-card);
}

.explainer h2 {
  font-size: 0.7rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 2px;
  color: var(--text-dim);
  margin-bottom: 18px;
}

.explainer-content {
  display: flex;
  flex-direction: column;
  gap: 14px;
}

.step {
  display: flex;
  gap: 14px;
  align-items: flex-start;
}

.step-num {
  flex-shrink: 0;
  width: 30px;
  height: 30px;
  border-radius: 50%;
  background: linear-gradient(135deg, var(--accent-blue), var(--accent-cyan));
  color: #fff;
  font-size: 0.8rem;
  font-weight: 700;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 10px rgba(99, 102, 241, 0.3);
}

.step p {
  font-size: 0.9rem;
  color: var(--text-muted);
  line-height: 1.6;
}

.step strong {
  color: var(--text);
  font-weight: 600;
}

.step em {
  color: var(--accent-cyan);
  font-style: normal;
  font-weight: 500;
}

/* ── Section headings ──────────────────────────────── */

section h2 {
  font-size: 0.85rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 2px;
  color: var(--text-dim);
  margin-bottom: 8px;
}

.section-desc {
  font-size: 0.9rem;
  color: var(--text-muted);
  margin-bottom: 20px;
  line-height: 1.6;
}

/* ── Combiner section ──────────────────────────────── */

.combiner-section {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 28px;
  margin-bottom: 36px;
  box-shadow: var(--shadow-card);
}

.combiner-inputs {
  display: flex;
  align-items: flex-end;
  gap: 20px;
  margin-bottom: 28px;
  justify-content: center;
}

.letter-input-group {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.letter-input-group label {
  font-size: 0.65rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: var(--text-dim);
}

.letter-input {
  width: 80px;
  height: 80px;
  font-family: 'Arial Black', 'Arial Bold', sans-serif;
  font-size: 2.2rem;
  text-align: center;
  text-transform: uppercase;
  background: var(--bg-input);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  outline: none;
  transition: all 0.2s;
}

.letter-input:focus {
  box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
}

.input-a {
  color: var(--accent-red);
}

.input-a:focus {
  border-color: var(--accent-red);
  box-shadow: 0 0 0 3px rgba(255, 77, 106, 0.15);
}

.input-b {
  color: var(--accent-blue);
}

.input-b:focus {
  border-color: var(--accent-blue);
  box-shadow: 0 0 0 3px rgba(124, 124, 255, 0.15);
}

.input-known {
  color: var(--accent-cyan);
}

.input-known:focus {
  border-color: var(--accent-cyan);
  box-shadow: 0 0 0 3px rgba(68, 224, 240, 0.15);
}

.combiner-op {
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--text-dim);
  padding-bottom: 22px;
}

/* ── Combiner result visual ────────────────────────── */

.combiner-result {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 14px;
  flex-wrap: wrap;
  padding: 24px 0;
  margin-bottom: 20px;
  min-height: 170px;
  background: rgba(0, 0, 0, 0.15);
  border-radius: var(--radius);
}

.vis-group {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.vis-group canvas {
  border-radius: var(--radius-sm);
  background: #fff;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.3);
}

.vis-label {
  font-size: 0.7rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1.5px;
}

.label-a { color: var(--accent-red); }
.label-b { color: var(--accent-blue); }
.label-and { color: var(--text-dim); }

.vis-op {
  font-size: 1.6rem;
  font-weight: 700;
  color: var(--text-dim);
  padding: 0 4px;
  align-self: center;
  margin-top: 16px;
  opacity: 0.6;
}

.vis-arrow {
  font-size: 2.2rem;
  color: var(--accent-green);
  opacity: 1;
}

.vis-match {
  justify-content: center;
}

.match-letter {
  font-family: 'Arial Black', 'Arial Bold', sans-serif;
  font-size: 4.5rem;
  font-weight: 900;
  color: var(--accent-green);
  line-height: 1;
  text-shadow: 0 0 30px rgba(61, 219, 160, 0.3);
}

.match-score {
  font-size: 0.75rem;
  color: var(--text-muted);
  font-weight: 600;
}

/* ── Combiner summary ──────────────────────────────── */

.combiner-summary {
  font-size: 0.95rem;
  color: var(--text-muted);
  text-align: center;
  line-height: 1.7;
}

.combiner-summary .hl-a { color: var(--accent-red); font-weight: 600; }
.combiner-summary .hl-b { color: var(--accent-blue); font-weight: 600; }
.combiner-summary .hl-result { color: var(--accent-green); font-size: 1.1rem; font-weight: 700; }

.runner-up {
  font-size: 0.8rem;
  color: var(--text-dim);
  margin-top: 6px;
}

/* ── Finder / Solver section ───────────────────────── */

.finder-section {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 28px;
  margin-bottom: 36px;
  box-shadow: var(--shadow-card);
}

/* ── Solver steps ─────────────────────────────────── */

.solver-steps {
  display: flex;
  flex-direction: column;
  gap: 20px;
  margin-bottom: 28px;
}

.solver-step {
  display: flex;
  gap: 16px;
  align-items: flex-start;
}

.solver-step-num {
  flex-shrink: 0;
  width: 30px;
  height: 30px;
  border-radius: 50%;
  background: linear-gradient(135deg, var(--accent-blue), var(--accent-cyan));
  color: #fff;
  font-size: 0.8rem;
  font-weight: 700;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 10px rgba(99, 102, 241, 0.3);
  margin-top: 2px;
}

.solver-step-content {
  flex: 1;
}

.solver-step-label {
  display: block;
  font-size: 0.8rem;
  font-weight: 600;
  color: var(--text-muted);
  margin-bottom: 10px;
}

.solver-step .letter-input {
  width: 72px;
  height: 72px;
  font-size: 2rem;
}

.solver-step .drop-zone {
  margin-bottom: 8px;
}

/* ── Solver result (the answer) ───────────────────── */

.solver-result {
  background: rgba(61, 219, 160, 0.06);
  border: 1px solid rgba(61, 219, 160, 0.2);
  border-radius: var(--radius);
  padding: 28px 20px;
  margin-bottom: 28px;
  text-align: center;
}

.solver-answer {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 14px;
  flex-wrap: wrap;
  margin-bottom: 20px;
}

.solver-answer-text {
  font-size: 1.3rem;
  color: var(--text);
  margin-bottom: 6px;
}

.solver-answer-text strong {
  font-family: 'Arial Black', 'Arial Bold', sans-serif;
  font-size: 1.8rem;
  color: var(--accent-green);
  text-shadow: 0 0 20px rgba(61, 219, 160, 0.3);
}

.solver-answer-score {
  font-size: 0.85rem;
  color: var(--accent-cyan);
  font-weight: 600;
  margin-bottom: 8px;
}

.solver-runners {
  font-size: 0.8rem;
  color: var(--text-dim);
}

/* ── Drop zone ─────────────────────────────────────── */

.drop-zone {
  border: 2px dashed var(--border-glow);
  border-radius: var(--radius);
  padding: 16px 16px;
  text-align: center;
  transition: all 0.25s;
  cursor: pointer;
  margin-bottom: 14px;
  background: rgba(0, 0, 0, 0.1);
}

.drop-zone:hover {
  border-color: var(--accent-blue);
  background: rgba(99, 102, 241, 0.05);
}

.drop-zone.drag-over {
  border-color: var(--accent-green);
  background: rgba(61, 219, 160, 0.08);
  border-style: solid;
  transform: scale(1.01);
}

.drop-zone.has-file {
  border-color: var(--accent-green);
  border-style: solid;
  padding: 18px 20px;
}

.drop-zone-content p {
  font-size: 0.9rem;
  color: var(--text-muted);
  margin: 0;
}

.drop-icon {
  font-size: 1.6rem;
  color: var(--text-dim);
  line-height: 1;
  margin-bottom: 4px;
  opacity: 0.5;
}

.drop-or {
  font-size: 0.75rem !important;
  color: var(--text-dim) !important;
  margin: 8px 0 !important;
}

.browse-btn {
  display: inline-block;
  font-size: 0.85rem;
  font-weight: 500;
  padding: 8px 22px;
  border: 1px solid var(--border);
  background: var(--bg-input);
  color: var(--text);
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: all 0.15s;
}

.browse-btn:hover {
  background: var(--bg-hover);
  border-color: var(--accent-blue);
  transform: translateY(-1px);
}

.browse-wrapper {
  position: relative;
  display: inline-block;
}

.browse-file-input {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  opacity: 0;
  cursor: pointer;
}

.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip-path: inset(50%);
  white-space: nowrap;
  border: 0;
}

/* ── Target preview ────────────────────────────────── */

.target-preview {
  display: flex;
  align-items: center;
  gap: 12px;
  min-height: 0;
}

.target-preview:empty {
  display: none;
}

.target-label {
  font-size: 0.75rem;
  color: var(--text-dim);
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.target-canvas {
  border-radius: var(--radius-sm);
  border: 1px solid var(--border);
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

/* ── Finder grid ───────────────────────────────────── */

.finder-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(105px, 1fr));
  gap: 10px;
}

.finder-empty {
  grid-column: 1 / -1;
  text-align: center;
  color: var(--text-dim);
  font-size: 0.9rem;
  padding: 24px;
}

.finder-card {
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 12px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 5px;
  position: relative;
  transition: all 0.2s;
}

.finder-card:hover {
  border-color: var(--accent-blue);
  transform: translateY(-3px);
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
}

.finder-card.high-match {
  border-color: var(--accent-green);
  box-shadow: 0 0 20px rgba(61, 219, 160, 0.15);
  background: rgba(61, 219, 160, 0.05);
}

.finder-card canvas {
  border-radius: var(--radius-sm);
  background: #fff;
  box-shadow: 0 1px 6px rgba(0, 0, 0, 0.2);
}

.card-header {
  font-size: 0.7rem;
  font-weight: 600;
  color: var(--text-muted);
}

.card-header .hl-a { color: var(--accent-red); }
.card-header .hl-b { color: var(--accent-blue); }

.card-looks {
  font-size: 0.8rem;
  color: var(--text-muted);
}

.card-looks strong {
  color: var(--accent-green);
  font-size: 0.9rem;
}

.card-score {
  font-size: 0.65rem;
  color: var(--accent-cyan);
  font-weight: 600;
}

.card-candidate {
  position: absolute;
  top: 7px;
  right: 9px;
  font-family: 'Arial Black', 'Arial Bold', sans-serif;
  font-size: 0.85rem;
  color: var(--text-dim);
  opacity: 0.4;
}

/* ── Shared highlight classes ──────────────────────── */

.hl-a { color: var(--accent-red); }
.hl-b { color: var(--accent-blue); }

/* ── Word Mode section ────────────────────────────── */

.word-section {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 28px;
  margin-bottom: 36px;
  box-shadow: var(--shadow-card);
  position: relative;
  overflow: hidden;
  min-height: 480px;
}

.word-header {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 8px;
}

.word-header h2 {
  margin-bottom: 0;
}

.lock-icon {
  font-size: 1rem;
  opacity: 0.6;
}

/* ── Word inputs ──────────────────────────────────── */

.word-inputs {
  display: flex;
  align-items: flex-end;
  gap: 20px;
  margin-bottom: 20px;
  justify-content: center;
}

.word-input-group {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.word-input-group label {
  font-size: 0.65rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: var(--text-dim);
}

.word-input {
  width: 200px;
  height: 56px;
  font-family: 'Arial Black', 'Arial Bold', sans-serif;
  font-size: 1.4rem;
  text-align: center;
  text-transform: uppercase;
  letter-spacing: 3px;
  background: var(--bg-input);
  border: 2px solid var(--border);
  border-radius: var(--radius);
  outline: none;
  transition: all 0.2s;
}

.word-input:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.word-input.input-a {
  color: var(--accent-red);
}

.word-input.input-a:focus {
  border-color: var(--accent-red);
  box-shadow: 0 0 0 3px rgba(255, 77, 106, 0.15);
}

.word-input.input-b {
  color: var(--accent-blue);
}

.word-input.input-b:focus {
  border-color: var(--accent-blue);
  box-shadow: 0 0 0 3px rgba(124, 124, 255, 0.15);
}

/* ── Word error ───────────────────────────────────── */

.word-error {
  text-align: center;
  font-size: 0.85rem;
  color: var(--text-dim);
  min-height: 1.4em;
  margin-bottom: 16px;
}

/* ── Word result grid ─────────────────────────────── */

.word-result {
  display: flex;
  gap: 10px;
  justify-content: center;
  flex-wrap: wrap;
  margin-bottom: 24px;
}

.wm-card {
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 12px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
  min-width: 90px;
  transition: all 0.2s;
}

.wm-card:hover {
  border-color: var(--accent-blue);
  transform: translateY(-2px);
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
}

.wm-card canvas {
  border-radius: var(--radius-sm);
  background: #fff;
  box-shadow: 0 1px 6px rgba(0, 0, 0, 0.2);
}

.wm-pos {
  font-size: 0.6rem;
  font-weight: 700;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 1px;
  opacity: 0.5;
}

.wm-pair {
  font-size: 0.75rem;
  font-weight: 600;
  color: var(--text-muted);
}

.wm-match {
  font-size: 0.85rem;
  color: var(--text-muted);
}

.wm-match strong {
  color: var(--accent-green);
  font-size: 1rem;
}

.wm-score {
  font-size: 0.65rem;
  color: var(--text-dim);
  font-weight: 600;
}

/* ── Word decoded result ──────────────────────────── */

.word-decoded {
  text-align: center;
  min-height: 0;
}

.word-decoded:empty {
  display: none;
}

.wm-decoded-text {
  font-family: 'Arial Black', 'Arial Bold', sans-serif;
  font-size: 3rem;
  font-weight: 900;
  letter-spacing: 6px;
  color: var(--accent-green);
  text-shadow: 0 0 30px rgba(61, 219, 160, 0.3);
  margin-bottom: 6px;
}

.wm-decoded-label {
  font-size: 0.8rem;
  color: var(--text-dim);
  font-weight: 500;
}

/* ── Paywall overlay ──────────────────────────────── */

.paywall-overlay {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(10, 10, 26, 0.85);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  z-index: 10;
  border-radius: var(--radius);
  padding: 24px;
}

.paywall-content {
  text-align: center;
  max-width: 380px;
}

.paywall-icon {
  font-size: 2.5rem;
  margin-bottom: 12px;
  opacity: 0.8;
}

.paywall-content h3 {
  font-size: 1.3rem;
  font-weight: 700;
  color: var(--text);
  margin-bottom: 8px;
}

.paywall-content > p {
  font-size: 0.9rem;
  color: var(--text-muted);
  line-height: 1.6;
  margin-bottom: 16px;
}

.paywall-price {
  font-size: 2rem;
  font-weight: 800;
  color: var(--accent-green);
  margin-bottom: 20px;
}

.paywall-price span {
  font-size: 0.85rem;
  font-weight: 500;
  color: var(--text-dim);
}

.paywall-email-group {
  display: flex;
  flex-direction: column;
  gap: 10px;
  align-items: center;
  margin-bottom: 14px;
}

.paywall-email-input {
  width: 100%;
  max-width: 300px;
  padding: 12px 16px;
  font-size: 0.95rem;
  font-family: 'Inter', sans-serif;
  background: var(--bg-input);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  color: var(--text);
  outline: none;
  text-align: center;
  transition: border-color 0.2s;
}

.paywall-email-input:focus {
  border-color: var(--accent-blue);
  box-shadow: 0 0 0 3px rgba(124, 124, 255, 0.15);
}

.paywall-email-input::placeholder {
  color: var(--text-dim);
}

.paywall-buy-btn {
  width: 100%;
  max-width: 300px;
  padding: 14px 24px;
  font-size: 1rem;
  font-weight: 700;
  font-family: 'Inter', sans-serif;
  border: none;
  border-radius: var(--radius-sm);
  background: linear-gradient(135deg, var(--accent-green), #2bc489);
  color: #0a0a1a;
  cursor: pointer;
  transition: all 0.2s;
  box-shadow: 0 4px 16px rgba(61, 219, 160, 0.3);
}

.paywall-buy-btn:hover:not(:disabled) {
  transform: translateY(-1px);
  box-shadow: 0 6px 24px rgba(61, 219, 160, 0.4);
}

.paywall-buy-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.paywall-alt {
  margin-top: 4px;
}

.paywall-signin-btn {
  background: none;
  border: none;
  color: var(--text-dim);
  font-size: 0.8rem;
  font-family: 'Inter', sans-serif;
  cursor: pointer;
  text-decoration: underline;
  text-underline-offset: 2px;
  transition: color 0.15s;
}

.paywall-signin-btn:hover {
  color: var(--accent-cyan);
}

.paywall-status {
  margin-top: 12px;
  font-size: 0.85rem;
  color: var(--text-muted);
  min-height: 1.2em;
}

.paywall-error {
  color: var(--accent-red);
}

/* ── Admin login (inside paywall) ────────────── */

.admin-section {
  margin-top: 18px;
}

.admin-toggle {
  background: none;
  border: none;
  color: var(--text-dim);
  font-size: 0.7rem;
  font-family: 'Inter', sans-serif;
  cursor: pointer;
  opacity: 0.5;
  transition: opacity 0.15s;
}

.admin-toggle:hover {
  opacity: 1;
  color: var(--text-muted);
}

.admin-form {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  margin-top: 10px;
}

.admin-input {
  width: 100%;
  max-width: 220px;
  padding: 8px 12px;
  font-size: 0.85rem;
  font-family: 'Inter', sans-serif;
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  color: var(--text);
  outline: none;
  text-align: center;
  transition: border-color 0.2s;
}

.admin-input:focus {
  border-color: var(--accent-blue);
}

.admin-submit-btn {
  padding: 8px 20px;
  font-size: 0.8rem;
  font-weight: 600;
  font-family: 'Inter', sans-serif;
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  background: var(--bg-input);
  color: var(--text-muted);
  cursor: pointer;
  transition: all 0.15s;
}

.admin-submit-btn:hover:not(:disabled) {
  border-color: var(--accent-blue);
  color: var(--text);
}

.admin-submit-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* ── Unlocked indicator ───────────────────────────── */

.word-unlocked {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  font-size: 0.8rem;
  color: var(--text-dim);
  margin-bottom: 16px;
  padding: 8px 16px;
  background: rgba(61, 219, 160, 0.06);
  border: 1px solid rgba(61, 219, 160, 0.15);
  border-radius: var(--radius-sm);
}

.word-unlocked strong {
  color: var(--accent-green);
}

.word-logout-btn {
  background: none;
  border: none;
  color: var(--text-dim);
  font-size: 0.75rem;
  font-family: 'Inter', sans-serif;
  cursor: pointer;
  text-decoration: underline;
  text-underline-offset: 2px;
}

.word-logout-btn:hover {
  color: var(--accent-red);
}

/* ── Responsive ────────────────────────────────────── */

@media (max-width: 640px) {
  .app {
    padding: 24px 14px 50px;
  }

  .app-header h1 {
    font-size: 1.8rem;
  }

  .combiner-inputs {
    gap: 12px;
  }

  .letter-input {
    width: 64px;
    height: 64px;
    font-size: 1.8rem;
  }

  .combiner-result {
    gap: 8px;
    padding: 16px 8px;
  }

  .vis-group canvas {
    width: 80px !important;
    height: 80px !important;
  }

  .vis-op {
    font-size: 1.2rem;
  }

  .match-letter {
    font-size: 3rem;
  }

  .finder-grid {
    grid-template-columns: repeat(auto-fill, minmax(88px, 1fr));
    gap: 6px;
  }

  .finder-card canvas {
    width: 52px !important;
    height: 52px !important;
  }

  .explainer,
  .combiner-section,
  .finder-section,
  .word-section {
    padding: 18px;
  }

  .solver-step .letter-input {
    width: 60px;
    height: 60px;
    font-size: 1.6rem;
  }

  .solver-answer {
    gap: 8px;
  }

  .solver-answer-text strong {
    font-size: 1.4rem;
  }

  .word-inputs {
    gap: 12px;
  }

  .word-input {
    width: 140px;
    height: 48px;
    font-size: 1.1rem;
    letter-spacing: 2px;
  }

  .wm-card {
    min-width: 72px;
    padding: 8px;
  }

  .wm-card canvas {
    width: 48px !important;
    height: 48px !important;
  }

  .wm-decoded-text {
    font-size: 2rem;
    letter-spacing: 4px;
  }
}

  </style>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LetterAND — Combine Letter Shapes</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>&#x1F50D;</text></svg>">
</head>
<body>
  <div class="app">

    <!-- Header -->
    <header class="app-header">
      <h1>LetterAND</h1>
      <p class="subtitle">See what two overlapping letters look like</p>
    </header>

    <!-- How it works -->
    <section class="explainer">
      <h2>How it works</h2>
      <div class="explainer-content">
        <div class="step">
          <span class="step-num">1</span>
          <p>Imagine printing two letters on top of each other. Only the parts where <em>both</em> letters have ink will show through.</p>
        </div>
        <div class="step">
          <span class="step-num">2</span>
          <p>The combined shape often looks like a completely different letter. For example, <strong>O</strong> and <strong>B</strong> together look like <strong>O</strong>, because the round part of B fits inside O.</p>
        </div>
        <div class="step">
          <span class="step-num">3</span>
          <p>You can also upload an image and let the tool figure out which letter combination produced it.</p>
        </div>
      </div>
    </section>

    <!-- ═══════════════════════════════════════════════ -->
    <!-- SECTION 1: Letter Combiner                     -->
    <!-- ═══════════════════════════════════════════════ -->
    <section class="combiner-section">
      <h2>Combine two letters</h2>
      <p class="section-desc">Pick any two letters and see what shape they make together.</p>

      <div class="combiner-inputs">
        <div class="letter-input-group">
          <label for="letterA">Letter A</label>
          <input type="text" id="letterA" maxlength="1" value="O" class="letter-input input-a" spellcheck="false" autocomplete="off">
        </div>
        <span class="combiner-op">&amp;</span>
        <div class="letter-input-group">
          <label for="letterB">Letter B</label>
          <input type="text" id="letterB" maxlength="1" value="B" class="letter-input input-b" spellcheck="false" autocomplete="off">
        </div>
      </div>

      <!-- Visual breakdown -->
      <div class="combiner-result" id="combinerResult">
        <!-- Filled by JS: letter A canvas, letter B canvas, = AND canvas, => best match -->
      </div>

      <div class="combiner-summary" id="combinerSummary">
        <!-- Filled by JS: text explanation of the result -->
      </div>
    </section>

    <!-- ═══════════════════════════════════════════════ -->
    <!-- SECTION 2: Letter Solver                       -->
    <!-- ═══════════════════════════════════════════════ -->
    <section class="finder-section">
      <h2>Solve a letter</h2>
      <p class="section-desc">Know one letter and have an image of the result? Enter the letter, upload the image, and we'll find the other letter.</p>

      <div class="solver-steps">
        <div class="solver-step">
          <span class="solver-step-num">1</span>
          <div class="solver-step-content">
            <label for="knownLetter" class="solver-step-label">Enter the known letter</label>
            <input type="text" id="knownLetter" maxlength="1" value="" class="letter-input input-known" spellcheck="false" autocomplete="off" placeholder="?">
          </div>
        </div>

        <div class="solver-step">
          <span class="solver-step-num">2</span>
          <div class="solver-step-content">
            <label class="solver-step-label">Upload the combined image</label>
            <div class="drop-zone" id="dropZone">
              <div class="drop-zone-content">
                <div class="drop-icon">+</div>
                <p>Drag & drop an image here</p>
                <p class="drop-or">or</p>
                <div class="browse-wrapper">
                  <span class="browse-btn">Browse files</span>
                  <input type="file" id="targetUpload" accept="image/*" class="browse-file-input">
                </div>
              </div>
            </div>
            <div class="target-preview" id="targetPreview">
              <!-- Shows uploaded target thumbnail -->
            </div>
          </div>
        </div>
      </div>

      <!-- Solver answer — shown after both letter + image provided -->
      <div class="solver-result" id="solverResult" style="display: none;">
        <!-- Filled by JS: the top match prominently displayed -->
      </div>

      <div class="finder-grid" id="finderGrid">
        <!-- Filled by JS: 26 cards, one per letter -->
      </div>
    </section>

    <!-- ═══════════════════════════════════════════════ -->
    <!-- SECTION 3: Word Mode (paid)                    -->
    <!-- ═══════════════════════════════════════════════ -->
    <section class="word-section" id="wordSection">
      <div class="word-header">
        <h2>Word Mode</h2>
        <span class="lock-icon" id="lockIcon">&#x1F512;</span>
      </div>
      <p class="section-desc">Enter two words of equal length and see what each letter position looks like combined.</p>

      <!-- Paywall overlay (shown when locked) -->
      <div class="paywall-overlay" id="paywallOverlay">
        <div class="paywall-content">
          <div class="paywall-icon">&#x1F512;</div>
          <h3>Unlock Word Mode</h3>
          <p>Combine entire words at once — see every letter position decoded side by side.</p>
          <div class="paywall-price">$4.99 <span>one-time</span></div>

          <div class="paywall-email-group" id="paywallEmailGroup">
            <input type="email" id="paywallEmail" placeholder="your@email.com" class="paywall-email-input" autocomplete="email">
            <button class="paywall-buy-btn" id="paywallBuyBtn">Unlock Word Mode</button>
          </div>

          <div class="paywall-alt">
            <button class="paywall-signin-btn" id="paywallSigninBtn">Already purchased? Sign in with your email</button>
          </div>

          <div class="paywall-status" id="paywallStatus"></div>

          <div class="admin-section">
            <button class="admin-toggle" id="adminToggle">Admin</button>
            <div class="admin-form" id="adminForm" style="display: none;">
              <input type="text" id="adminUser" placeholder="Username" class="admin-input" autocomplete="username">
              <input type="password" id="adminPass" placeholder="Password" class="admin-input" autocomplete="current-password">
              <button class="admin-submit-btn" id="adminSubmit">Sign in</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Unlocked indicator -->
      <div class="word-unlocked" id="wordUnlocked" style="display: none;">
        <span>Signed in as <strong id="wordEmail"></strong></span>
        <button class="word-logout-btn" id="wordLogoutBtn">Sign out</button>
      </div>

      <!-- Word inputs (disabled when locked) -->
      <div class="word-inputs" id="wordInputs">
        <div class="word-input-group">
          <label for="wordA">Word A</label>
          <input type="text" id="wordA" placeholder="HELLO" class="word-input input-a" spellcheck="false" autocomplete="off" disabled>
        </div>
        <span class="combiner-op">&amp;</span>
        <div class="word-input-group">
          <label for="wordB">Word B</label>
          <input type="text" id="wordB" placeholder="WORLD" class="word-input input-b" spellcheck="false" autocomplete="off" disabled>
        </div>
      </div>

      <div class="word-error" id="wordError"></div>

      <div class="word-result" id="wordResult">
        <!-- Filled by JS: one card per letter position -->
      </div>

      <div class="word-decoded" id="wordDecoded">
        <!-- Filled by JS: the decoded result word -->
      </div>
    </section>

  </div>

  

  <script>
// Core AND logic — pure computation, no DOM dependencies

const CELL = 200
const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

/**
 * Render a single letter to an offscreen canvas and return its ImageData.
 */
function renderLetter(ch, fontSize) {
  const c = document.createElement('canvas')
  c.width = CELL
  c.height = CELL
  const ctx = c.getContext('2d')
  ctx.fillStyle = '#fff'
  ctx.fillRect(0, 0, CELL, CELL)
  ctx.fillStyle = '#000'
  const scaledFont = Math.round(fontSize * (CELL / 80))
  ctx.font = `${scaledFont}px "Arial Black", "Arial Bold", sans-serif`
  ctx.textAlign = 'center'
  ctx.textBaseline = 'middle'
  ctx.fillText(ch.toUpperCase(), CELL / 2, CELL / 2 + Math.round(CELL * 0.02))
  return ctx.getImageData(0, 0, CELL, CELL)
}

/**
 * Convert ImageData to a binary mask (1 = dark pixel, 0 = light).
 */
function toBinary(imageData) {
  const d = imageData.data
  const mask = new Uint8Array(CELL * CELL)
  for (let i = 0; i < mask.length; i++) {
    const brightness = (d[i * 4] + d[i * 4 + 1] + d[i * 4 + 2]) / 3
    mask[i] = brightness < 128 ? 1 : 0
  }
  return mask
}

/**
 * Bitwise AND two binary masks.
 */
function andMasks(a, b) {
  const result = new Uint8Array(a.length)
  for (let i = 0; i < a.length; i++) result[i] = a[i] & b[i]
  return result
}

/**
 * Score how well a candidate mask matches a target using IoU + F1 blend.
 */
function matchScore(candidate, target) {
  let inter = 0, cSum = 0, tSum = 0
  for (let i = 0; i < candidate.length; i++) {
    if (candidate[i]) cSum++
    if (target[i]) tSum++
    if (candidate[i] && target[i]) inter++
  }
  if (cSum === 0 && tSum === 0) return 1
  if (cSum === 0 || tSum === 0) return 0
  const union = cSum + tSum - inter
  const iou = inter / union
  const prec = inter / cSum
  const rec = inter / tSum
  const f1 = (prec + rec) > 0 ? 2 * prec * rec / (prec + rec) : 0
  return 0.4 * iou + 0.6 * f1
}

/**
 * Build binary masks for every letter A-Z at a given font size.
 */
function buildLetterMasks(fontSize) {
  const masks = {}
  for (const ch of ALPHABET) {
    masks[ch] = toBinary(renderLetter(ch, fontSize))
  }
  return masks
}

/**
 * Find the top-N best matching letters for a given mask.
 */
function findBestMatches(mask, letterMasks, topN) {
  const scores = []
  for (const ch of ALPHABET) {
    scores.push({ ch, score: matchScore(letterMasks[ch], mask) })
  }
  scores.sort((a, b) => b.score - a.score)
  return scores.slice(0, topN)
}

/**
 * Draw a binary mask onto a canvas with the given RGB color.
 */
function drawMask(canvas, mask, r, g, b) {
  const ctx = canvas.getContext('2d')
  const img = ctx.createImageData(CELL, CELL)
  for (let i = 0; i < mask.length; i++) {
    img.data[i * 4] = mask[i] ? r : 255
    img.data[i * 4 + 1] = mask[i] ? g : 255
    img.data[i * 4 + 2] = mask[i] ? b : 255
    img.data[i * 4 + 3] = 255
  }
  ctx.putImageData(img, 0, 0)
}

// UI logic for combiner + finder modes
  CELL, ALPHABET, buildLetterMasks, andMasks,
  drawMask, findBestMatches, matchScore, toBinary,
} from './engine.js'

// Default font size (maps to 300px on the 200x200 canvas)
const FONT_SIZE = 120

// Cached letter masks (rebuilt only when needed)
let masks = null

function getMasks() {
  if (!masks) masks = buildLetterMasks(FONT_SIZE)
  return masks
}

// ── DOM refs ───────────────────────────────────────────

let els = {}

function initElements() {
  els = {
    // Combiner
    letterA: document.getElementById('letterA'),
    letterB: document.getElementById('letterB'),
    combinerResult: document.getElementById('combinerResult'),
    combinerSummary: document.getElementById('combinerSummary'),
    // Finder / Solver
    knownLetter: document.getElementById('knownLetter'),
    targetUpload: document.getElementById('targetUpload'),
    targetPreview: document.getElementById('targetPreview'),
    dropZone: document.getElementById('dropZone'),
    solverResult: document.getElementById('solverResult'),
    finderGrid: document.getElementById('finderGrid'),
  }
}

// ── Helpers ────────────────────────────────────────────

function clearEl(el) {
  while (el.firstChild) el.removeChild(el.firstChild)
}

function makeCanvas(mask, r, g, b, cssSize) {
  const cv = document.createElement('canvas')
  cv.width = CELL
  cv.height = CELL
  if (cssSize) {
    cv.style.width = cssSize + 'px'
    cv.style.height = cssSize + 'px'
  }
  drawMask(cv, mask, r, g, b)
  return cv
}

function parseLetter(input) {
  const val = input.value.toUpperCase().replace(/[^A-Z]/g, '')
  return val.length > 0 ? val[0] : null
}

// ── Combiner ───────────────────────────────────────────

function updateCombiner() {
  const chA = parseLetter(els.letterA)
  const chB = parseLetter(els.letterB)
  clearEl(els.combinerResult)
  clearEl(els.combinerSummary)

  if (!chA || !chB) {
    els.combinerSummary.textContent = 'Enter two letters above to see the result.'
    return
  }

  const m = getMasks()
  const maskA = m[chA]
  const maskB = m[chB]
  const maskAND = andMasks(maskA, maskB)
  const best = findBestMatches(maskAND, m, 3)

  // Build visual: [A] & [B] = [AND] => "X"
  const row = els.combinerResult

  // Letter A
  const groupA = document.createElement('div')
  groupA.className = 'vis-group'
  const labelA = document.createElement('div')
  labelA.className = 'vis-label label-a'
  labelA.textContent = chA
  groupA.appendChild(labelA)
  groupA.appendChild(makeCanvas(maskA, 233, 69, 96, 120))
  row.appendChild(groupA)

  // Operator &
  const opAnd = document.createElement('span')
  opAnd.className = 'vis-op'
  opAnd.textContent = '&'
  row.appendChild(opAnd)

  // Letter B
  const groupB = document.createElement('div')
  groupB.className = 'vis-group'
  const labelB = document.createElement('div')
  labelB.className = 'vis-label label-b'
  labelB.textContent = chB
  groupB.appendChild(labelB)
  groupB.appendChild(makeCanvas(maskB, 67, 97, 238, 120))
  row.appendChild(groupB)

  // Operator =
  const opEq = document.createElement('span')
  opEq.className = 'vis-op'
  opEq.textContent = '='
  row.appendChild(opEq)

  // AND result
  const groupAND = document.createElement('div')
  groupAND.className = 'vis-group'
  const labelAND = document.createElement('div')
  labelAND.className = 'vis-label label-and'
  labelAND.textContent = 'AND'
  groupAND.appendChild(labelAND)
  groupAND.appendChild(makeCanvas(maskAND, 34, 34, 34, 120))
  row.appendChild(groupAND)

  // Arrow =>
  const opArrow = document.createElement('span')
  opArrow.className = 'vis-op vis-arrow'
  opArrow.textContent = '\u2192'
  row.appendChild(opArrow)

  // Best match letter
  const groupMatch = document.createElement('div')
  groupMatch.className = 'vis-group vis-match'
  const matchLetter = document.createElement('div')
  matchLetter.className = 'match-letter'
  matchLetter.textContent = best[0].ch
  groupMatch.appendChild(matchLetter)
  const matchScore = document.createElement('div')
  matchScore.className = 'match-score'
  matchScore.textContent = `${(best[0].score * 100).toFixed(0)}% match`
  groupMatch.appendChild(matchScore)
  row.appendChild(groupMatch)

  // Summary text
  const summary = els.combinerSummary
  const p1 = document.createElement('p')
  p1.innerHTML = `<strong class="hl-a">${chA}</strong> combined with <strong class="hl-b">${chB}</strong> looks like <strong class="hl-result">${best[0].ch}</strong>.`
  summary.appendChild(p1)

  if (best.length > 1) {
    const p2 = document.createElement('p')
    p2.className = 'runner-up'
    const runners = best.slice(1).map(b => `${b.ch} (${(b.score * 100).toFixed(0)}%)`).join(', ')
    p2.textContent = `Also similar to: ${runners}`
    summary.appendChild(p2)
  }
}

// ── Finder / Solver ───────────────────────────────────────

let targetImage = null
let targetMask = null

function setupFinder() {
  // File upload (click)
  els.targetUpload.addEventListener('change', (e) => {
    const file = e.target.files[0]
    if (file) loadTargetFile(file)
  })

  // Click on drop zone (outside the file input) opens file picker
  els.dropZone.addEventListener('click', (e) => {
    if (!e.target.closest('.browse-wrapper')) {
      els.targetUpload.click()
    }
  })

  // Drag and drop
  const dz = els.dropZone
  dz.addEventListener('dragover', (e) => {
    e.preventDefault()
    dz.classList.add('drag-over')
  })
  dz.addEventListener('dragleave', () => {
    dz.classList.remove('drag-over')
  })
  dz.addEventListener('drop', (e) => {
    e.preventDefault()
    dz.classList.remove('drag-over')
    const file = e.dataTransfer.files[0]
    if (file && file.type.startsWith('image/')) loadTargetFile(file)
  })

  // Known letter input
  els.knownLetter.addEventListener('input', updateFinder)
}

function loadTargetFile(file) {
  const reader = new FileReader()
  reader.onload = (ev) => {
    const img = new Image()
    img.onload = () => {
      targetImage = img
      targetMask = imageToMask(img)
      showTargetPreview(img)
      els.dropZone.classList.add('has-file')
      updateFinder()
    }
    img.src = ev.target.result
  }
  reader.readAsDataURL(file)
}

function imageToMask(img) {
  const c = document.createElement('canvas')
  c.width = CELL
  c.height = CELL
  const ctx = c.getContext('2d')
  ctx.fillStyle = '#fff'
  ctx.fillRect(0, 0, CELL, CELL)
  ctx.drawImage(img, 0, 0, CELL, CELL)
  return toBinary(ctx.getImageData(0, 0, CELL, CELL))
}

function showTargetPreview(img) {
  clearEl(els.targetPreview)
  const h = 80
  const w = Math.round(img.width * (h / img.height))
  const cv = document.createElement('canvas')
  cv.width = w
  cv.height = h
  cv.style.width = w + 'px'
  cv.style.height = h + 'px'
  cv.className = 'target-canvas'
  const ctx = cv.getContext('2d')
  ctx.drawImage(img, 0, 0, w, h)

  const label = document.createElement('span')
  label.className = 'target-label'
  label.textContent = 'Target:'
  els.targetPreview.appendChild(label)
  els.targetPreview.appendChild(cv)
}

function updateFinder() {
  clearEl(els.finderGrid)
  clearEl(els.solverResult)
  els.solverResult.style.display = 'none'

  const known = parseLetter(els.knownLetter)
  if (!known) {
    const msg = document.createElement('p')
    msg.className = 'finder-empty'
    msg.textContent = 'Start by entering a letter above.'
    els.finderGrid.appendChild(msg)
    return
  }

  if (!targetMask) {
    const msg = document.createElement('p')
    msg.className = 'finder-empty'
    msg.textContent = 'Now upload the combined image to find the other letter.'
    els.finderGrid.appendChild(msg)
    return
  }

  // We have both a known letter and a target image — solve it
  const m = getMasks()
  const results = []

  for (const ch of ALPHABET) {
    const maskAND = andMasks(m[known], m[ch])
    const ts = matchScore(maskAND, targetMask)
    results.push({ ch, maskAND, targetScore: ts })
  }

  results.sort((a, b) => b.targetScore - a.targetScore)

  // ── Prominent solver answer ──────────────────────
  const best = results[0]
  els.solverResult.style.display = 'block'

  const answerRow = document.createElement('div')
  answerRow.className = 'solver-answer'

  // Show: [known] & [?] = [AND image] → answer letter
  const groupKnown = document.createElement('div')
  groupKnown.className = 'vis-group'
  const labelKnown = document.createElement('div')
  labelKnown.className = 'vis-label label-a'
  labelKnown.textContent = known
  groupKnown.appendChild(labelKnown)
  groupKnown.appendChild(makeCanvas(m[known], 233, 69, 96, 100))
  answerRow.appendChild(groupKnown)

  const opAnd = document.createElement('span')
  opAnd.className = 'vis-op'
  opAnd.textContent = '&'
  answerRow.appendChild(opAnd)

  const groupAnswer = document.createElement('div')
  groupAnswer.className = 'vis-group'
  const labelAnswer = document.createElement('div')
  labelAnswer.className = 'vis-label label-b'
  labelAnswer.textContent = best.ch
  groupAnswer.appendChild(labelAnswer)
  groupAnswer.appendChild(makeCanvas(m[best.ch], 67, 97, 238, 100))
  answerRow.appendChild(groupAnswer)

  const opEq = document.createElement('span')
  opEq.className = 'vis-op'
  opEq.textContent = '='
  answerRow.appendChild(opEq)

  const groupAND = document.createElement('div')
  groupAND.className = 'vis-group'
  const labelAND = document.createElement('div')
  labelAND.className = 'vis-label label-and'
  labelAND.textContent = 'result'
  groupAND.appendChild(labelAND)
  groupAND.appendChild(makeCanvas(best.maskAND, 34, 34, 34, 100))
  answerRow.appendChild(groupAND)

  els.solverResult.appendChild(answerRow)

  // Answer text
  const answerText = document.createElement('div')
  answerText.className = 'solver-answer-text'
  answerText.innerHTML = `The other letter is <strong>${best.ch}</strong>`
  els.solverResult.appendChild(answerText)

  const answerScore = document.createElement('div')
  answerScore.className = 'solver-answer-score'
  answerScore.textContent = `${(best.targetScore * 100).toFixed(0)}% match`
  els.solverResult.appendChild(answerScore)

  // Runner-ups
  if (results.length > 1) {
    const runners = results.slice(1, 4)
    const runnerText = document.createElement('div')
    runnerText.className = 'solver-runners'
    runnerText.textContent = 'Also possible: ' + runners.map(r => `${r.ch} (${(r.targetScore * 100).toFixed(0)}%)`).join(', ')
    els.solverResult.appendChild(runnerText)
  }

  // ── Full grid (secondary detail) ─────────────────
  for (const r of results) {
    const card = document.createElement('div')
    card.className = 'finder-card'
    if (r.targetScore > 0.7) card.classList.add('high-match')

    const header = document.createElement('div')
    header.className = 'card-header'
    header.innerHTML = `<span class="hl-a">${known}</span> & <span class="hl-b">${r.ch}</span>`
    card.appendChild(header)

    card.appendChild(makeCanvas(r.maskAND, 34, 34, 34, 64))

    const score = document.createElement('div')
    score.className = 'card-score'
    score.textContent = `${(r.targetScore * 100).toFixed(0)}% match`
    card.appendChild(score)

    const candidateLabel = document.createElement('div')
    candidateLabel.className = 'card-candidate'
    candidateLabel.textContent = r.ch
    card.appendChild(candidateLabel)

    els.finderGrid.appendChild(card)
  }
}

// Word Mode — paid feature: combine two full words position-by-position
  CELL, buildLetterMasks, andMasks,
  drawMask, findBestMatches,
} from './engine.js'

const FONT_SIZE = 120
let masks = null

function getMasks() {
  if (!masks) masks = buildLetterMasks(FONT_SIZE)
  return masks
}

function clearEl(el) {
  while (el.firstChild) el.removeChild(el.firstChild)
}

function makeCanvas(mask, r, g, b, cssSize) {
  const cv = document.createElement('canvas')
  cv.width = CELL
  cv.height = CELL
  if (cssSize) {
    cv.style.width = cssSize + 'px'
    cv.style.height = cssSize + 'px'
  }
  drawMask(cv, mask, r, g, b)
  return cv
}

function parseLine(val) {
  return val.toUpperCase().replace(/[^A-Z]/g, '')
}

let els = {}

function initWordMode() {
  els = {
    wordA: document.getElementById('wordA'),
    wordB: document.getElementById('wordB'),
    wordResult: document.getElementById('wordResult'),
    wordDecoded: document.getElementById('wordDecoded'),
    wordError: document.getElementById('wordError'),
  }
  if (!els.wordA) return // not in DOM yet

  els.wordA.addEventListener('input', updateWordMode)
  els.wordB.addEventListener('input', updateWordMode)
}

function updateWordMode() {
  if (!els.wordA) return

  const a = parseLine(els.wordA.value)
  const b = parseLine(els.wordB.value)

  clearEl(els.wordResult)
  clearEl(els.wordDecoded)
  els.wordError.textContent = ''

  if (!a || !b) {
    els.wordError.textContent = 'Enter two words above to see results.'
    return
  }

  if (a.length !== b.length) {
    els.wordError.textContent = `Words must be the same length. "${a}" has ${a.length} letters, "${b}" has ${b.length}.`
    return
  }

  const m = getMasks()
  const decoded = []

  for (let i = 0; i < a.length; i++) {
    const chA = a[i]
    const chB = b[i]
    const maskA = m[chA]
    const maskB = m[chB]
    const maskAND = andMasks(maskA, maskB)
    const best = findBestMatches(maskAND, m, 1)[0]
    decoded.push(best.ch)

    // Build card for this position
    const card = document.createElement('div')
    card.className = 'wm-card'

    // Position header
    const pos = document.createElement('div')
    pos.className = 'wm-pos'
    pos.textContent = i + 1

    // Letter pair
    const pair = document.createElement('div')
    pair.className = 'wm-pair'
    pair.innerHTML = `<span class="hl-a">${chA}</span> & <span class="hl-b">${chB}</span>`

    // AND canvas
    const canvas = makeCanvas(maskAND, 34, 34, 34, 64)

    // Result letter
    const result = document.createElement('div')
    result.className = 'wm-match'
    result.innerHTML = `&rarr; <strong>${best.ch}</strong>`

    // Score
    const score = document.createElement('div')
    score.className = 'wm-score'
    score.textContent = `${(best.score * 100).toFixed(0)}%`

    card.appendChild(pos)
    card.appendChild(pair)
    card.appendChild(canvas)
    card.appendChild(result)
    card.appendChild(score)
    els.wordResult.appendChild(card)
  }

  // Show decoded word
  const decodedText = document.createElement('div')
  decodedText.className = 'wm-decoded-text'
  decodedText.textContent = decoded.join('')
  els.wordDecoded.appendChild(decodedText)

  const decodedLabel = document.createElement('div')
  decodedLabel.className = 'wm-decoded-label'
  decodedLabel.textContent = `${a} AND ${b}`
  els.wordDecoded.appendChild(decodedLabel)
}

// Client-side access management for Word Mode paywall

const STORAGE_KEY = 'letterand_access'

function getStored() {
  try {
    return JSON.parse(localStorage.getItem(STORAGE_KEY)) || null
  } catch { return null }
}

function setStored(data) {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data))
}

/** Check if user has unlocked access (from localStorage cache) */
function isUnlocked() {
  const stored = getStored()
  return stored?.access === true
}

/** Get stored email */
function getEmail() {
  return getStored()?.email || null
}

/** Verify a Stripe Checkout session_id and store result */
async function unlock(sessionId) {
  const res = await fetch('/api/verify-payment', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ session_id: sessionId }),
  })
  const data = await res.json()
  if (data.access) {
    setStored({ access: true, email: data.email })
  }
  return data
}

/** Check if an email has a completed purchase */
async function checkEmail(email) {
  const res = await fetch('/api/check-access', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email }),
  })
  const data = await res.json()
  if (data.access) {
    setStored({ access: true, email })
  }
  return data
}

/** Admin bypass login */
async function adminLogin(username, password) {
  const res = await fetch('/api/admin-login', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ username, password }),
  })
  const data = await res.json()
  if (data.access) {
    setStored({ access: true, email: data.email })
  }
  return data
}

/** Start the Stripe Checkout flow */
async function startCheckout(email) {
  const res = await fetch('/api/create-checkout', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email }),
  })
  const data = await res.json()
  if (data.url) {
    window.location.href = data.url
  }
  return data
}

/** Clear stored access */
function logout() {
  localStorage.removeItem(STORAGE_KEY)
}

// Entry point — wires up combiner, finder, auth, and word mode

document.addEventListener('DOMContentLoaded', async () => {
  initElements()
  setupFinder()

  // Combiner inputs
  const letterA = document.getElementById('letterA')
  const letterB = document.getElementById('letterB')
  letterA.addEventListener('input', updateCombiner)
  letterB.addEventListener('input', updateCombiner)

  // Initial render
  updateCombiner()
  updateFinder()

  // ── Auth + Word Mode ───────────────────────────────
  initWordMode()

  const paywallOverlay = document.getElementById('paywallOverlay')
  const paywallEmail = document.getElementById('paywallEmail')
  const paywallBuyBtn = document.getElementById('paywallBuyBtn')
  const paywallSigninBtn = document.getElementById('paywallSigninBtn')
  const paywallStatus = document.getElementById('paywallStatus')
  const wordUnlocked = document.getElementById('wordUnlocked')
  const wordEmailEl = document.getElementById('wordEmail')
  const wordLogoutBtn = document.getElementById('wordLogoutBtn')
  const lockIcon = document.getElementById('lockIcon')
  const wordA = document.getElementById('wordA')
  const wordB = document.getElementById('wordB')

  function setUnlockedUI() {
    paywallOverlay.style.display = 'none'
    wordUnlocked.style.display = 'flex'
    lockIcon.innerHTML = '&#x1F513;'
    wordA.disabled = false
    wordB.disabled = false
    const email = getEmail()
    if (email) wordEmailEl.textContent = email
  }

  function setLockedUI() {
    paywallOverlay.style.display = 'flex'
    wordUnlocked.style.display = 'none'
    lockIcon.innerHTML = '&#x1F512;'
    wordA.disabled = true
    wordB.disabled = true
    // Reset admin form
    const af = document.getElementById('adminForm')
    if (af) af.style.display = 'none'
  }

  function setStatus(msg, isError) {
    paywallStatus.textContent = msg
    paywallStatus.className = 'paywall-status' + (isError ? ' paywall-error' : '')
  }

  // Check for returning from Stripe Checkout
  const params = new URLSearchParams(window.location.search)
  const sessionId = params.get('session_id')
  if (sessionId) {
    setStatus('Verifying payment...', false)
    try {
      const result = await unlock(sessionId)
      if (result.access) {
        setUnlockedUI()
        // Clean up URL
        window.history.replaceState({}, '', window.location.pathname)
      } else {
        setStatus('Payment not confirmed yet. Please try again.', true)
      }
    } catch {
      setStatus('Error verifying payment. Please try again.', true)
    }
  } else if (isUnlocked()) {
    setUnlockedUI()
  } else {
    setLockedUI()
  }

  // Buy button
  paywallBuyBtn.addEventListener('click', async () => {
    const email = paywallEmail.value.trim()
    if (!email || !email.includes('@')) {
      setStatus('Please enter a valid email address.', true)
      return
    }
    paywallBuyBtn.disabled = true
    paywallBuyBtn.textContent = 'Redirecting...'
    setStatus('', false)
    try {
      await startCheckout(email)
    } catch {
      setStatus('Error starting checkout. Please try again.', true)
      paywallBuyBtn.disabled = false
      paywallBuyBtn.textContent = 'Unlock Word Mode'
    }
  })

  // Sign in with email (already purchased)
  paywallSigninBtn.addEventListener('click', async () => {
    const email = paywallEmail.value.trim()
    if (!email || !email.includes('@')) {
      setStatus('Please enter your email address above first.', true)
      return
    }
    paywallSigninBtn.disabled = true
    paywallSigninBtn.textContent = 'Checking...'
    setStatus('', false)
    try {
      const result = await checkEmail(email)
      if (result.access) {
        setUnlockedUI()
      } else {
        setStatus('No purchase found for this email. Try a different email or purchase below.', true)
      }
    } catch {
      setStatus('Error checking access. Please try again.', true)
    }
    paywallSigninBtn.disabled = false
    paywallSigninBtn.textContent = 'Already purchased? Sign in with your email'
  })

  // Logout
  wordLogoutBtn.addEventListener('click', () => {
    logout()
    setLockedUI()
    paywallEmail.value = ''
    setStatus('', false)
  })

  // Admin toggle + login
  const adminToggle = document.getElementById('adminToggle')
  const adminForm = document.getElementById('adminForm')
  const adminSubmit = document.getElementById('adminSubmit')

  adminToggle.addEventListener('click', () => {
    const hidden = adminForm.style.display === 'none'
    adminForm.style.display = hidden ? 'flex' : 'none'
  })

  adminSubmit.addEventListener('click', async () => {
    const username = document.getElementById('adminUser').value.trim()
    const password = document.getElementById('adminPass').value
    if (!username || !password) {
      setStatus('Enter admin credentials.', true)
      return
    }
    adminSubmit.disabled = true
    adminSubmit.textContent = 'Checking...'
    try {
      const result = await adminLogin(username, password)
      if (result.access) {
        setUnlockedUI()
      } else {
        setStatus('Invalid admin credentials.', true)
      }
    } catch {
      setStatus('Admin login error.', true)
    }
    adminSubmit.disabled = false
    adminSubmit.textContent = 'Sign in'
  })
})
  </script>
</body>
</html>
